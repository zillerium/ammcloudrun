# classcode/benchmark.py
import numpy as np
from classcode.ystate import YState
from classcode.checkstates import CheckStates

class BenchmarkAMM:
    def __init__(self, xb=1_000_000, yb=1_000_000, A=100, n=200,
                 csv_file="/tmp/stableswap.csv", csv_remote="stableswap.csv",
                 plot_file="/tmp/stableswap.png", plot_remote="stableswap.png"):
        self.xb = xb
        self.yb = yb
        self.A = A
        self.n = n
        self.csv_file = csv_file
        self.csv_remote = csv_remote
        self.plot_file = plot_file
        self.plot_remote = plot_remote

        self.pool = YState(self.xb, self.yb, self.A)
        self.checker = CheckStates(self.A, self.pool.D)
        ## self.x_values = np.linspace(self.xb / 2, self.xb * 1.5, self.n)
        self.x_values = np.linspace(self.xb / 10, self.xb *4 , self.n)

        self.y_values = []
        self.delta_values = []

    def run_test(self):
        rows = []
        for x in self.x_values:
            y = self.pool.get_y(x)
            delta = self.checker.delta(x, y)
            rows.append([x, y, delta])
            self.y_values.append(y)
            self.delta_values.append(delta)
        return rows

# classcode/calcprice.py
import csv
import matplotlib.pyplot as plt
from uploader import upload_file
from classcode.plotamm import PlotAMM

class CalcPrice(PlotAMM):
    """
    Extends PlotAMM to compute prices for n=2 and
    save CSV with columns: x, y, delta, p,
    plus a price-vs-x plot.
    """

    def compute_price(self, x: float, y: float) -> float:
        D = self.pool.D
        print(f"ðŸ”Ž Debug: using D = {D} for x={x}, y={y}")
        numerator = 4 * self.A + (D**3) / (4 * (x**2) * y)
        denominator = 4 * self.A + (D**3) / (4 * x * (y**2))
        print(f"ðŸ”Ž Debug: num and dem num ={numerator} dem={denominator}")
        return numerator / denominator

    def generate_csv_with_price(self):
        rows = self.run_test()

        priced_rows = []
        prices = []
        for (x, y, delta) in rows:
            p = self.compute_price(x, y)
            priced_rows.append([x, y, delta, p])
            prices.append(p)

        # Save CSV locally
        with open(self.csv_file, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["x", "y", "delta", "p"])
            writer.writerows(priced_rows)
        print(f"âœ… CSV with price saved locally at {self.csv_file}")

        # Upload CSV to S3
        csv_result = upload_file(self.csv_file, self.csv_remote)
        print("âœ… CSV upload result:", csv_result)

        # --- Plot price vs. x ---
        plt.figure(figsize=(8, 6))
        plt.plot(self.x_values, prices, label=f"Price (A={self.A})")
        plt.axhline(1.0, color="k", linestyle="--", label="Balanced price p=1")
        plt.title("StableSwap Price Curve")
        plt.xlabel("x")
        plt.ylabel("Price p")
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.savefig(self.plot_file)
        print(f"âœ… Price plot saved locally at {self.plot_file}")

        plot_result = upload_file(self.plot_file, self.plot_remote)
        print("âœ… Plot upload result:", plot_result)

        return {"csv": csv_result, "plot": plot_result}

# classcode/checkstates.py
class CheckStates:
    """
    Validates (x, y) points against StableSwap invariant (n=2).
    """
    def __init__(self, A: int, D: float):
        self.A = A
        self.D = D

    def delta(self, x: float, y: float) -> float:
        lhs = 4 * self.A * (x + y) + self.D
        rhs = 4 * self.A * self.D + self.D**3 / (4 * x * y)
        return lhs - rhs

# classcode/dstate.py
import math

class DState:
    """
    Represents the invariant state of the AMM: x, y, A, D.
    D is computed from x, y, A at initialization.
    """
    def __init__(self, xb: float, yb: float, A: int):
        self.x = float(xb)
        self.y = float(yb)
        self.A = int(A)
        self.D = self._calculate_D(xb, yb)

    def _calculate_D(self, x: float, y: float) -> float:
        """Newton iteration for n=2 case."""
        S = x + y
        if S == 0:
            return 0

        D = S
        Ann = self.A * 4

        for _ in range(255):
            D_P = D * D * D / (4 * x * y)
            D_prev = D
            numerator = (Ann * S + D_P * 2) * D
            denominator = (Ann - 1) * D + D_P * 3
            D = numerator / denominator
            if abs(D - D_prev) <= 1:
                break
        return D

# classcode/plotamm.py
import csv
import matplotlib.pyplot as plt
from uploader import upload_file
from classcode.benchmark import BenchmarkAMM

class PlotAMM(BenchmarkAMM):
    def generate_csv_and_plot(self):
        rows = self.run_test()

        # Save CSV
        with open(self.csv_file, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["x", "y", "delta"])
            writer.writerows(rows)
        print(f"âœ… CSV saved locally at {self.csv_file}")

        csv_result = upload_file(self.csv_file, self.csv_remote)
        print("âœ… CSV upload result:", csv_result)

        # Plot
        plt.figure(figsize=(8, 6))
        plt.plot(self.x_values, self.y_values, label=f"StableSwap A={self.A}")
        plt.plot(self.x_values,
                 self.xb + self.yb - self.x_values,
                 "k--", label="y = L - x")
        plt.title("StableSwap Invariant Curve")
        plt.xlabel("x")
        plt.ylabel("y")
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.savefig(self.plot_file)
        print(f"âœ… Plot saved locally at {self.plot_file}")

        plot_result = upload_file(self.plot_file, self.plot_remote)
        print("âœ… Plot upload result:", plot_result)

        return {"csv": csv_result, "plot": plot_result}

# classcode/plotmulti.py
import matplotlib.pyplot as plt
from uploader import upload_file
from classcode.benchmark import BenchmarkAMM

class PlotMultiAMM:
    """
    Plot multiple StableSwap invariant curves for different A values.
    """
    def __init__(self, xb=1_000_000, yb=1_000_000, A_list=None, n=200,
                 plot_file="/tmp/stableswap_multi.png", plot_remote="stableswap_multi.png"):
        self.xb = xb
        self.yb = yb
        self.A_list = A_list or [1, 10, 100, 1000]
        self.n = n
        self.plot_file = plot_file
        self.plot_remote = plot_remote

    def generate_plot(self):
        plt.figure(figsize=(8, 6))

        # loop over A values and reuse BenchmarkAMM
        for A in self.A_list:
            benchmark = BenchmarkAMM(self.xb, self.yb, A, self.n)
            benchmark.run_test()
            plt.plot(benchmark.x_values, benchmark.y_values, label=f"A={A}")

        # straight-line reference
        #plt.plot(benchmark.x_values,
        #         self.xb + self.yb - benchmark.x_values,
        #         "k--", label="y = L - x")

        rows = benchmark.run_test()

        # keep only positive y values
        x_vals = []
        y_vals = []
        for x, y, _ in rows:
            if y <= 0:
                break
            x_vals.append(x)
            y_vals.append(y)

        plt.plot(x_vals, y_vals, label=f"A={A}")


        plt.title(f"StableSwap Curves for A={min(self.A_list)}â€“{max(self.A_list)}")
        plt.xlabel("x")
        plt.ylabel("y")
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.savefig(self.plot_file)
        print(f"âœ… Multi-plot saved locally at {self.plot_file}")

        result = upload_file(self.plot_file, self.plot_remote)
        print("âœ… Upload result:", result)
        return result

# classcode/ystate.py
from .dstate import DState

class YState(DState):
    """
    Computes y given x, based on fixed A and D inherited from DState.
    """
    def get_y(self, x_new: float) -> float:
        Ann = self.A * 4
        D = self.D
        c = D**3 / (4 * Ann * x_new)
        b = x_new + D / Ann

        y_prev = D
        for _ in range(255):
            y = y_prev
            y_prev = (y * y + c) / (2 * y + b - D)
            if abs(y - y_prev) <= 1:
                break
        return y_prev

